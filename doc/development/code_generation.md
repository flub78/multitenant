# Code Generation

This project extends on the Laravel idea to use php artisan to generate migrations, controllers, models, etc.

Usually code templates generated by artisan are just files with a simple example. They can generate controller, model, htlm forms to create or edit an element, and so on. They usually require a significant amount of adaptation.

This generator uses data extracted from the database schema to adapt the templates. For example, after generation, create and edit forms contains code to input every field. In a lot of cases the generator is able to generate a full CRUD module fully operational.

With this framework, developers can develop code for every data type instead of code for every data. Inside an application the quantity of information is usually much bigger than the number of data types. In a previous similar project I measured a ratio of 37 to 1 and I expect it to grow with the size of the application. 

It is a bet that the time spent to develop the infrastructure will be compensated by more productivity. It requires however to use the framework at a sufficiently large scale.

Generated code has often several drawbacks.
* It is usually ugly and difficult to understand
* It is often difficult to debug because of the reason above and because there is no tools working at the abstraction level of the code generator
* It is often slow and inefficient

By generating code with templates:
* Generated code can be as clean, as well indented and commented than manual code.
* As the code looks like manually written code, it is as fast.
* And it is as clean than manual code, it is not more difficult to debug.
* The code generator can compare the generated code with the one already active in the application. It shows the two version in WinMerge making easy to mix generated code and manually written code.

The goal is to generate code indistinguishable from manual code.

With this template mechanism it is possible to generate quickly a basic application. Of course complex resources will need tuning and adaptations but the intial version should work out of the box. In this context a resource may be a database table but also the result of a joint stored as a view in the database. It is the generalization of the idea of automated CRUD generator to complex views result of select implicating several tables.

     
## Use cases

Depending on the size of the application we can expect between twenty and a few hundred different resources.

As a developer 
- I want to generate one file from one table or view (processing one template)
- I want to generate all the code for one table
- I want to compare the generated result with the current version. 
- I want to replace a current version with the generated file.

Existing templates:
* controller
* request: to validate HTML requests
* model: for database interface
* factory: to generate elements for tests
* create: a form to create elements
* edit: a form to edit existing elements
* index: a blade template to display a list of elements
* english: a language file containing the strings to display
* test_model: a test for the model
* test_controller: a test for the controller
* test_dusk: an end to end test for the resource
* api: an API for programmatic acccess to the resource
* test_api: a test for this API
* migration, to generate a migration when the table has already been created in database
* doc : display some advices and describes actions required after generation.

## Translation

[Google automatic translation of the application](translation.md)
    
## Supported data types

* [Code generator data types](code_generation_data_types.md)

## Design

There is a tradeoff between cases supported by the generator and its complexity. Making the generator more complex can be long and the gain in productivity may become marginal or null. Keeping it too simple increase the chances to have to manually edit the result.
    
## Implementation

## The database schema

Information about the existing tables, their fields and their data types are fetched from the database itself by the Schema model. This model also collects information about the existing indexes.

This approach implies a very clean database schema in wich all the data constraints or relationship are described in the database. For example foreign keys need to be declared. Special indexes have to be created to enforce unicity, etc. 

Another example, the field size must be exact in the database if the developer intends to limit the size of a string. The rules for string validation will be derived from the database field size and not the other way around. 

## The Metadata

The information extracted from the schema are useful but not sufficient to define the treatments to apply to data types. For example a VARCHAR may be used to store a postal address, an email address or a name and each case must be handled differently. 

The information fetched from the database schema is complemented by metadata information stored in the database itself, in a table named metadata, or json encoded inside the MySql fields comments.

The central application has much less feature than the tenant application. So this mechanism will be initially developed for tenants database only.


### List of metadata

Here is the list of types, subtypes and metadata annotation supported by the generator.

* types
    * varchar
    * integers
    * float
    * date
    * time
    * datetime
    
* subtype
    * email
    * checkbox
    * foreign keys
    * password_with_confirmation
    * datetime_with_date_and_time
    * color
    * enumerate
    * bitfield
    * picture
    * file
    * currency
    * text (multilines)
    
* fillable
    * yes | no
    
* inTable
    * yes | no
    
* inForm
    * yes | no
    
* comment

* rules_to_add, rules_to_replace, create_rules_to_add, create_rules_to_replace, edit_rules_to_add and edit_rules_to_replace
    * list of rules to replace existing ones or be merged with the existing ones

* enumerate
    * list of possible values for the field, either a flat list, or an associative array to specify displayed values and encoding.
    
* attrs
    * a way to generate HTML attributes
    
* default
    
## Templating mechanism

The information fetched from the database is used to tune and adapt templates. Templates 
can be used to generate controllers, models, validation rules in request, factories, model unit tests and controller unit tests, in fact all type of files which differ only by the data types that they handle.

The mustache template engine has been selected for the generator. It is a very generic template mechanism that has no dependencies to any development environment and available in multiple languages. 

To generate a file from a template the user needs to specify a template, a database table and a result destination.
Template and result can be specified as absolute file names or relative to the template and the result directory.


### List of replaced patterns

This list is partial and not necessarily up to date. Look inside the templates and the CodeGenerator helper. 

    [[class_name]]              Camel case class name (model)
    [[fillable_names]]          List of fields
    [[element]]                 resource element
    [[table]]                   Database table name
    [[primary_index]]           Name of the primary index (often id)
    
    [[#select_list]]
        [[&selector]]
        [[&with]]
    [[/select_list]]
    
    [[# select_with_list ]]     
    [[/ select_with_list ]]
    
    [[# form_field_list ]]      List of fields for a form
        [[&label]]              with its label
        [[&input_create]]       create form item
        [[&input_edit]]         edit form item
        [[name]]
        [[&faker]]
    [[/ form_field_list ]]
    
    [[# table_field_list ]]     List of fields for a table
        [[element]]             
        [[name]]
    [[/ table_field_list ]]
    
    [[& button_edit ]]          Button to call the edit form
    [[& button_delete ]]        Button to delete an element
     

### Data flow

1. For each table database schema and metadata are parsed.
2. Then the mustache template engine uses these data to generate blade templates and controller or request code.
3. At runtime when a request is made, the views are generated and cached
4. Laravel code is executed, controllers, Validation, etc.

Some HTML code is static (known when the schema and metadata are known) but other is dynamic, like a select which depends on a field value to determine what option has to be marked as selected.

In the first case, the code is generated by the code generator. In the second case the code generator generates a dynamic call to a function that will be called at runtime to generate the actual code.

### The template directory

It contains all the templates, optionally in sub directories.

### The result directory

Contains the files after that the templates have been processed.

### The application directory

It is where the generated files are copied once the generated code is acceptable. The install option replace the existing version by the one generated by the code generator.


## The php artisan command

The whole mechanism is available through a few php artisan commands:

    php artisan mustache:generate users controller -v
    
    php artisan mustache:generate --compare table model
    php artisan mustache:generate --install table edit
    php artisan mustache:info calendar_events
    
table is a database table name
     
    mustache:generate process a template or a set of templates

    The compare option compares and displays the differences between the generated files and the one of the application

    the install options copies the generated files into the application

    mustache:info just dump the metadata about one table
     
# The mustache documentation

    https://faun.pub/dynamic-content-in-your-mails-using-mustache-9f3a660462ad
    https://github.com/bobthecow/mustache.php/wiki
    
# Design notes

## setters and mutators

A resource attribute is an abstract element of a resource object that can be read or set. In a lot of case there is a direct equivalence between the attribute and the way it is stored in database. For example a name is a string resource attribute which is stored directly into a varchar.

In some case it may be convenient to not store exactly what is displayed. Dates for example are stored as "Y-m-d" strings in the database but are displayed or input as date in local format. Mutators and setters are a convenient place to make this translation work. See getBirthdayAttribute and setBirthdayAttribute in CodeGenType for example.

## Derived fields

In some cases one column in database requires several fields in form for creation or modification. It is the case for password which have a validation field, for bitfields for which one integer in database is set with multiple checkboxes, etc.

Setters and Getters are used to change the format of a field having a different representation internally and externally. In case of localization for example, the external format may depend on the current timezone, while the internal does not.

Note that it makes sense to have in some case multiple fields to create or update a single table resource column. But what about list of elements (index view) ? For the list it makes more sense to have one array column per resource field and to use a display function to format them.

## MySql views

The code generator can also generates code to handle MySql views.

Supported templates:
* controller (limited to read methods)
* model for persistency (read only)
* index a blade template to display a list of elements
* test_model a test for the model (read only)
* test_controller a test for the controller (read only)
* test_dusk an end to end test for the resource (read only)
* api an API for programmatic acccess to the resource (read only)
* test_api a test for this API (limited to read methods) 

Non supported templates (Views are not supposed to be used to create or edit resources)
* request to validate HTML requests
* factory to generate elements for tests
* create a form to create elements
* edit a form to edit existing elements
* english, views uses the string of the target field

As a MySql view resource is read only, maybe that it would be cleaner to have specific templates ...   

* [MySQL Views](mysql_views.md)
* [MySQL Queries](mysql_queries.md)

## Migration Generation

Code generation of migrations is a special case. In a way if a table already exists in the database you do not really need a migration to create it. And usually when you write a migration the table does not exist.

However it may be convenient during development to generate the table manually with a graphical tool like phpmyadmin and when you are happy with the result to generate the migration. It is faster than using the standard php artisan make:migration because the migration is already filled.

If you are more comfortable in creating the tables by writing migrations just do not use this feature.

    